<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>USA Hybrid Clean â€“ Panel Multiday</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Chart.js para grÃ¡ficas -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
:root {
  --bg: #0b0f18;
  --bg-soft: #121a26;
  --bg-card: #0e1622;
  --bg-glass: rgba(17, 27, 39, 0.55);
  --accent: #3dbff7;
  --accent-alt: #6366f1;
  --accent-soft: rgba(61, 191, 247, 0.18);
  --accent-gradient: linear-gradient(135deg, #3dbff7 0%, #6366f1 100%);
  --text: #e2e8f0;
  --muted: #94a3b8;
  --danger: #fb6e6e;
  --ok: #4ade80;
  --warn: #facc15;
  --info: #60a5fa;
  --border: #1e293b;
  --shadow-deep: 0 18px 38px -12px rgba(0,0,0,0.55), 0 8px 18px -8px rgba(0,0,0,0.5);

  /* Layout full-width (sin mÃ¡rgenes laterales del body) */
  --container-max: 100%;
  --container-px-left: 0px;
  --container-px-right: 0px;

  /* Defaults UI */
  --sidebar-w: clamp(240px, 25vw, 320px);
  --chart-h: 280px;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

/* Full viewport, sin espacio lateral */
html, body { width: 100%; max-width: 100vw; overflow-x: hidden; }
body {
  margin: 0; padding: 0;
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background:
    radial-gradient(circle at 15% 20%, rgba(61,191,247,0.09), transparent 60%),
    radial-gradient(circle at 85% 30%, rgba(99,102,241,0.10), transparent 65%),
    linear-gradient(160deg, #09121d 0%, #061019 50%, #09121d 100%);
  color: var(--text);
  min-height: 100vh;
  position: relative;
}
body::before { /* sutil textura */
  content: ""; position: fixed; inset: 0; pointer-events: none; opacity: 0.08;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" viewBox="0 0 400 400"><g fill="none" stroke="%233dbff733" stroke-width="0.5"><path d="M0 200h400M200 0v400"/></g></svg>');
  background-size: 240px 240px; mix-blend-mode: overlay;
}

/* HEADER -------------------------------------------------- */
header {
  padding: 0.95rem 0; border-bottom: 1px solid var(--border);
  background: linear-gradient(90deg, rgba(14,22,34,0.9) 0%, rgba(14,22,34,0.6) 55%, rgba(14,22,34,0.9) 100%);
  backdrop-filter: blur(14px) saturate(160%);
  position: sticky; top: 0; z-index: 60;
  box-shadow: 0 4px 20px -6px rgba(0,0,0,0.45);
}

/* contenedor sin margen del body, pero con respiraciÃ³n interna */
.container {
  width: 100%;
  max-width: 100%;
  margin: 0;
  padding: 0 0.75rem;  /* <- padding interno, NO margen del body */
}

header .inner {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.8rem;
}

header h1 { margin: 0; font-size: 1.1rem; letter-spacing: 0.05em; font-weight:600; background: var(--accent-gradient); -webkit-background-clip: text; background-clip: text; color: transparent; }

header .subtitle {
  font-size: 0.8rem;
  color: var(--muted);
  margin-top: 0.2rem;
}

header .actions {
  display: flex;
  gap: 0.6rem;
  align-items: center;
  flex-wrap: wrap;
}

/* BOTONES / PILLS ---------------------------------------- */
.btn {
  border-radius: 14px; padding: 0.55rem 1rem; font-weight:500;
  border: 1px solid rgba(61,191,247,0.25);
  background: linear-gradient(145deg, rgba(17,27,39,0.92), rgba(20,32,46,0.92));
  color: var(--text); font-size: 0.78rem; cursor: pointer;
  display: inline-flex; align-items: center; gap: 0.45rem; position: relative;
  transition: background 0.22s, transform 0.18s, box-shadow 0.22s, border-color 0.22s;
  box-shadow: 0 3px 10px -4px rgba(0,0,0,0.5);
}
.btn:hover {
  background: linear-gradient(145deg, rgba(26,40,54,0.95), rgba(30,48,66,0.95));
  border-color: rgba(61,191,247,0.45);
  box-shadow: 0 6px 18px -6px rgba(0,0,0,0.6), 0 0 0 1px rgba(61,191,247,0.35);
  transform: translateY(-2px);
}
.btn:active { transform: translateY(0); box-shadow: 0 2px 8px -2px rgba(0,0,0,0.55); }
.btn[disabled] { opacity:0.55; cursor: not-allowed; }
.btn .pulse {
  position:absolute; inset:0; border-radius:inherit; pointer-events:none; opacity:0; animation:pulse 2.2s infinite;
  background: radial-gradient(circle at 30% 30%, rgba(61,191,247,0.35), transparent 70%);
}
@keyframes pulse { 0%{opacity:0;} 15%{opacity:0.55;} 35%{opacity:0;} 100%{opacity:0;} }
.btn span.icon { font-size: 0.9rem; }

.pill {
  display: inline-flex;
  align-items: center;
  padding: 0.18rem 0.6rem;
  border-radius: 9999px;
  border: 1px solid rgba(148,163,184,0.5);
  font-size: 0.7rem;
  color: var(--muted);
  gap: 0.25rem;
  background: rgba(15,23,42,0.85);
}

/* LAYOUT PRINCIPAL --------------------------------------- */
#layout {
  width: 100%;
  max-width: 100%;
  margin: 0;
  padding: 1.25rem 0.75rem 2rem; /* <- padding interno, sin expansiÃ³n lateral */
  display: flex;
  gap: 1rem;
  align-items: flex-start;
}

#sidebar {
  flex: 0 0 var(--sidebar-w);
  min-width: 220px;
  max-width: 360px;
}

#sidebar .card {
  position: sticky;
  top: 4.5rem;
  max-height: calc(100vh - 6rem);
  overflow: auto;
}

main {
  flex: 1 1 auto;
  min-width: 0;  /* <- clave para evitar overflow horizontal */
}

/* GRID GENERAL (tarjetas) -------------------------------- */
.grid {
  display: grid;
  grid-template-columns: repeat(12, minmax(0,1fr));
  gap: 1rem;
  min-width: 0;
}

.card {
  background: var(--bg-glass);
  backdrop-filter: blur(18px) saturate(170%);
  border-radius: 18px; border: 1px solid rgba(255,255,255,0.05);
  padding: 1rem 1.15rem; position: relative; overflow: hidden; min-width:0;
  box-shadow: var(--shadow-deep);
}
.card::after { content:""; position:absolute; inset:0; background:linear-gradient(140deg, rgba(61,191,247,0.05), rgba(99,102,241,0.07)); pointer-events:none; }
.card:hover { box-shadow: 0 20px 40px -10px rgba(0,0,0,0.6); }

/* Controles de ediciÃ³n por tarjeta (layout editable) */
.card-controls {
  position: absolute;
  top: 0.6rem;
  right: 0.6rem;
  display: none;
  gap: 0.4rem;
  align-items: center;
  background: rgba(2, 6, 23, 0.7);
  border: 1px solid var(--border);
  border-radius: 0.5rem;
  padding: 0.25rem 0.4rem;
  z-index: 3;
}
.card-controls select,
.card-controls input[type="number"] {
  background: rgba(15,23,42,0.95);
  color: var(--text);
  border: 1px solid #334155;
  border-radius: 0.35rem;
  font-size: 0.72rem;
  padding: 0.15rem 0.35rem;
  width: auto;
}
body.edit-layout .card-controls { display: inline-flex; }

.card::before {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at top right, rgba(56,189,248,0.14), transparent 55%);
  opacity: 0.6;
  pointer-events: none;
}
.card > * { position: relative; z-index: 1; }

.card h2 {
  margin: 0 0 0.4rem;
  font-size: 0.95rem;
  font-weight: 600;
  color: #e5f0ff;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.card h2 span.icon { font-size: 1rem; }
.card p { margin: 0; font-size: 0.8rem; color: var(--muted); }

/* KPIs --------------------------------------------------- */
.kpi-value {
  font-size: 1.5rem;
  font-weight: 600;
  margin-top: 0.4rem;
  color: #f9fafb;
}
.kpi-label {
  font-size: 0.8rem;
  color: var(--muted);
  margin-top: 0.15rem;
}
.kpi-chip {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.15rem 0.5rem;
  border-radius: 9999px;
  font-size: 0.7rem;
  border: 1px solid rgba(148,163,184,0.4);
  background: rgba(15,23,42,0.9);
  margin-left: 0.4rem;
}

/* SECCIONES / TITULOS ------------------------------------ */
.section-title {
  margin: 1.4rem 0 0.6rem;
  font-size: 0.95rem;
  font-weight: 600;
  color: #e5f0ff;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.section-title span.icon { font-size: 1rem; }

/* TABLAS ------------------------------------------------- */
.table-container {
  max-height: 340px;
  overflow: auto;
  overflow-x: auto;
  max-width: 100%;
  border-radius: 0.75rem;
  border: 1px solid var(--border);
  background: rgba(15,23,42,0.7);
  backdrop-filter: blur(10px);
}
table { width:100%; border-collapse:collapse; font-size:0.75rem; table-layout:auto; }
th, td { padding:0.5rem 0.65rem; text-align:left; border-bottom:1px solid rgba(45,55,72,0.55); white-space:nowrap; }
th {
  font-weight:500; color: var(--text); background: linear-gradient(180deg, #162231 0%, #121a26 100%);
  position:sticky; top:0; z-index:3; letter-spacing:0.5px;
  box-shadow: 0 2px 0 rgba(0,0,0,0.4);
}
tbody tr { transition: background 0.18s; }
tbody tr:nth-child(even) td { background: rgba(17,27,39,0.55); }
tbody tr:nth-child(odd) td { background: rgba(14,22,34,0.55); }
tbody tr:hover td { background: rgba(34,49,66,0.75); }

/* ESTADOS / BADGES --------------------------------------- */
.badge-ok { color: var(--ok); }
.badge-fail { color: var(--danger); }
.badge-warn { color: var(--warn); }

.status-activo { color: var(--accent); font-weight: 600; }
.status-tp-hit { color: var(--ok); font-weight: 600; }
.status-sl-hit { color: var(--danger); font-weight: 600; }

/* Buffers / Alertas -------------------------------------- */
.alert-banner { padding:0.75rem 1.4rem; margin:1rem 0; border-radius:14px; border:1px solid rgba(250,204,21,0.35); background:linear-gradient(140deg, rgba(250,204,21,0.15), rgba(251,191,36,0.12)); color:var(--warn); font-size:0.78rem; display:flex; align-items:center; gap:0.6rem; }

.alert-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 1.5rem;
  height: 1.5rem;
  margin-left: 0.3rem;
  cursor: help;
  position: relative;
  font-size: 1rem;
}
.alert-icon .tooltip {
  visibility: hidden;
  opacity: 0;
  position: absolute;
  bottom: 130%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(15, 23, 42, 0.98);
  color: var(--warn);
  padding: 0.6rem 0.9rem;
  border-radius: 0.5rem;
  font-size: 0.75rem;
  white-space: nowrap;
  border: 1px solid var(--warn);
  box-shadow: 0 10px 25px rgba(0,0,0,0.6);
  z-index: 100;
  transition: opacity 0.2s, visibility 0.2s;
  pointer-events: none;
}
.alert-icon .tooltip::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: var(--warn);
}
.alert-icon:hover .tooltip { visibility: visible; opacity: 1; }

/* Texto utilitario --------------------------------------- */
.muted { color: var(--muted); }

/* CANVAS CHARTS ------------------------------------------ */
canvas {
  width: 100% !important;
  height: var(--chart-h, 280px) !important;
}

/* DOTS --------------------------------------------------- */
.status-dot {
  width: 0.6rem;
  height: 0.6rem;
  border-radius: 9999px;
  display: inline-block;
  margin-right: 0.3rem;
}
.status-ok { background: var(--ok); }
.status-warn { background: var(--warn); }
.status-bad { background: var(--danger); }

/* CALENDARIO: riesgo / filtros --------------------------- */
.risk-cell { font-weight: 500; }
.risk-cell.risk-low { background: rgba(74,222,128,0.15); }
.risk-cell.risk-medium { background: rgba(250,204,21,0.18); }
.risk-cell.risk-high { background: rgba(249,115,115,0.25); }

.badge-holiday {
  display: inline-block;
  padding: 0.1rem 0.4rem;
  border-radius: 0.5rem;
  background: rgba(167,139,250,0.18);
  color: #c4b5fd;
  font-size: 0.6rem;
  border: 1px solid rgba(167,139,250,0.4);
  margin-left: 0.3rem;
}

.risk-pill {
  position: relative;
  border-color: rgba(148,163,184,0.6);
}
.risk-pill.risk-low {
  border-color: rgba(74,222,128,0.5);
  background: rgba(22,163,74,0.18);
  color: #bbf7d0;
}
.risk-pill.risk-medium {
  border-color: rgba(250,204,21,0.6);
  background: rgba(161,98,7,0.2);
  color: #facc15;
}
.risk-pill.risk-high {
  border-color: rgba(248,113,113,0.7);
  background: rgba(127,29,29,0.35);
  color: #fecaca;
  box-shadow: 0 0 0 1px rgba(248,113,113,0.35);
}

/* tooltip dentro del pill de riesgo */
.risk-pill .tooltip {
  visibility: hidden;
  opacity: 0;
  position: absolute;
  left: 50%;
  bottom: 115%;
  transform: translateX(-50%);
  background: rgba(15,23,42,0.97);
  padding: 0.55rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.65rem;
  color: #e5e7eb;
  min-width: 190px;
  border: 1px solid var(--accent-soft);
  box-shadow: 0 10px 25px rgba(0,0,0,0.7);
  transition: opacity 0.15s;
  z-index: 200;
}
.risk-pill .tooltip::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: var(--accent);
}
.risk-pill:hover .tooltip { visibility: visible; opacity: 1; }

/* Evitar expansiÃ³n horizontal por textos largos en Calendario */
#upcoming-days { table-layout: fixed; width: 100%; }
#upcoming-days th:nth-child(1),
#upcoming-days td:nth-child(1) { width: 24%; }
#upcoming-days th:nth-child(2),
#upcoming-days td:nth-child(2) { width: 16%; }
#upcoming-days th:nth-child(3),
#upcoming-days td:nth-child(3) { width: 16%; }
#upcoming-days th:nth-child(4),
#upcoming-days td:nth-child(4) { width: 44%; }

#upcoming-days th,#upcoming-days td { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
#upcoming-days td:nth-child(4),
#upcoming-days th:nth-child(4) {
  white-space: normal;
}

/* RESPONSIVE --------------------------------------------- */
@media (max-width: 1200px) {
  #layout { flex-direction: column; }
  #sidebar { flex: 1 1 auto; max-width: 100%; }
  #sidebar .card { position: relative; top: 0; max-height: none; }
}

@media (max-width: 900px) {
  header .inner { flex-direction: column; align-items: flex-start; }
  header .actions { width: 100%; justify-content: flex-start; }
  .grid { grid-template-columns: 1fr; }
}

@media (max-width: 600px) {
  #layout { padding: 0.8rem 0.6rem 1.5rem; }
  .card { padding: 0.9rem 0.95rem; }
}
  /* Custom scrollbar */
  ::-webkit-scrollbar { width:10px; height:10px; }
  ::-webkit-scrollbar-track { background: rgba(255,255,255,0.04); }
  ::-webkit-scrollbar-thumb { background: linear-gradient(180deg,#3dbff7,#6366f1); border-radius:20px; border:2px solid #0e1622; }
  ::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg,#50c6fa,#7a7df5); }

  footer.site-footer { margin-top:2.5rem; padding:1.2rem 1rem 2.4rem; text-align:center; font-size:0.65rem; color:var(--muted); opacity:0.9; }
  footer.site-footer a { color: var(--accent); text-decoration:none; }
  footer.site-footer a:hover { text-decoration:underline; }

  /* Loader global overlay + spinner */
  .loader-overlay { position:fixed; inset:0; background:rgba(11,15,24,0.55); backdrop-filter:blur(6px) saturate(140%); display:none; align-items:center; justify-content:center; z-index:1000; }
  .loader-box { background:rgba(15,23,42,0.9); border:1px solid var(--border); padding:1.1rem 1.5rem 1.25rem; border-radius:1rem; box-shadow:var(--shadow-deep); text-align:center; min-width:240px; }
  /* Overlay ayuda API caÃ­da */
  .api-help-overlay { position:fixed; inset:0; background:rgba(9,13,20,0.82); backdrop-filter:blur(10px) saturate(160%); display:none; align-items:center; justify-content:center; z-index:1200; }
  .api-help-box { max-width:680px; background:linear-gradient(135deg, rgba(17,27,39,0.92), rgba(25,39,56,0.94)); border:1px solid rgba(61,191,247,0.35); border-radius:18px; padding:1.4rem 1.6rem 1.8rem; color:var(--text); box-shadow:0 25px 40px -12px rgba(0,0,0,0.7); font-size:0.78rem; line-height:1.35; }
  .api-help-box h2 { margin-top:0; font-size:1rem; font-weight:600; }
  .api-help-box ol { margin:0.75rem 0 0; padding-left:1rem; }
  .api-help-box li { margin:0.4rem 0; }
  .api-help-box code { background:#0b1120; padding:0.15rem 0.35rem; border-radius:4px; font-size:0.7rem; }
  .api-help-dismiss { margin-top:1rem; display:inline-flex; align-items:center; gap:0.4rem; background:var(--accent-gradient); color:#fff; border:none; padding:0.55rem 1rem; border-radius:12px; cursor:pointer; font-size:0.72rem; font-weight:600; }
  .loader-box .spinner { width:38px; height:38px; border:4px solid rgba(61,191,247,0.35); border-top-color: var(--accent); border-radius:50%; animation: spin 0.9s linear infinite; margin:0 auto 0.9rem; }
  .loader-box .msg { font-size:0.75rem; color:var(--muted); }
  @keyframes spin { from { transform:rotate(0deg);} to { transform:rotate(360deg);} }

  /* BotÃ³n estado cargando */
  .btn.btn-loading { pointer-events:none; opacity:0.85; }
  .btn.btn-loading::after { content:""; position:absolute; right:10px; top:50%; transform:translateY(-50%); width:16px; height:16px; border:2px solid var(--accent); border-top-color:transparent; border-radius:50%; animation: spin 0.8s linear infinite; }

  /* Refuerzo visual encabezados de tarjeta */
  .card h2 { position:relative; }
  .card h2::after { content:""; flex:1; height:1px; background:linear-gradient(90deg, rgba(61,191,247,0.4), rgba(99,102,241,0)); display:block; position:absolute; left: calc(100% + 0.6rem); top:50%; transform:translateY(-50%); width:60px; pointer-events:none; }

  /* KPI row uniform heights */
  .kpi-card { display:flex; flex-direction:column; justify-content:flex-start; min-height:180px; }
  .kpi-card .kpi-value { margin-top:0.4rem; }
  .kpi-card .kpi-label { margin-top:auto; padding-top:0.4rem; }

  /* Vertical rhythm utilities */
  .section-block { margin-top:2.0rem; }
  .section-block:first-of-type { margin-top:0; }
  main > section.grid { margin-bottom:1.6rem; }

  /* Header alignment improvements */
  header .inner { align-items:flex-end; }
  header h1 { line-height:1.2; }
  header .subtitle { margin-top:0.25rem; line-height:1.1; }
  header .actions { align-items:flex-end; }
  .actions .btn { display:inline-flex; align-items:center; }

  /* Consistent h3 styling */
  h3.section-title, .card h3 { font-weight:600; letter-spacing:0.5px; }
  .card h3 { display:flex; align-items:center; gap:0.4rem; }

  /* Table container spacing normalization */
  .table-container { margin-top:0.4rem; }
  .table-container + .table-container { margin-top:1rem; }

  /* Commented style guide reference */
  /*
    Style Guide (Resumen rÃ¡pido):
    - Spacing vertical principal: 1.6rem entre bloques mayores.
    - Tarjetas KPI: min-height 180px para evitar saltos.
    - Iconos en encabezados: alineados con flex y gap 0.4rem.
    - Botones header: misma lÃ­nea base, spinner integrado con ::after.
    - Secciones: usar .section-block para agrupaciones nuevas.
  */
  </style>
</head>

<body>
<header>
  <div class="container inner">
    <div>
      <h1>USA Hybrid Clean Â· Multiday</h1>
      <div class="subtitle">Monitor de salud Â· posiciones Â· PnL Â· progreso a TP Â· buffers</div>
    </div>
    <div class="actions">
      <label style="font-size:0.8rem;color:var(--muted);display:flex;align-items:center;gap:0.3rem;">
        Auto-refresh:
        <select id="autoRefreshSelect" style="background:rgba(15,23,42,0.9);color:var(--text);border:1px solid var(--border);border-radius:0.25rem;padding:0.25rem 0.5rem;font-size:0.8rem;">
          <option value="0">Manual</option>
          <option value="30">30s</option>
          <option value="60" selected>60s</option>
          <option value="300">5min</option>
        </select>
      </label>

      <button class="btn" id="reloadButton">
        <span class="icon">âŸ³</span>
        <span>Actualizar</span>
      </button>

      <span class="alert-icon" id="staleBufferIcon" style="display:none;">
        <span style="color: var(--warn);">âš ï¸</span>
        <span class="tooltip" id="staleBufferTooltip">Buffers desactualizados</span>
      </span>

      <span class="pill">
        <span class="icon">ğŸ§ª</span>
        <span id="lastUpdatedLabel">Cargandoâ€¦</span>
      </span>

      <button class="btn" id="toggleLayoutEdit"><span class="icon">âš™ï¸</span> Editar layout</button>
      <button class="btn" id="resetLayout" title="Restablecer tamaÃ±os guardados">â†º Reset</button>
  <button class="btn" id="btnPredicciones" title="Generar predicciones y plan para maÃ±ana"><span class="icon">ğŸ¤–</span><span>Predicciones MaÃ±ana</span></button>
  <button class="btn" id="btnRefreshBuffers" title="Descargar datos intradÃ­a para plan"><span class="icon">ğŸ“¡</span><span>Refrescar Buffers</span></button>
    </div>
  </div>
</header>

<!-- Loader Overlay (inicialmente oculto) -->
<div id="loaderOverlay" class="loader-overlay">
  <div class="loader-box">
    <div class="spinner"></div>
    <div class="msg" id="loaderMsg">Procesandoâ€¦</div>
  </div>
</div>

<div id="layout">
  <aside id="sidebar">
    <!-- Sidebar Calendario & Riesgo -->
    <div class="card" id="calendar-card" data-card-id="calendar" style="height:100%; display:flex; flex-direction:column;">
      <h2><span class="icon">ğŸ“…</span> Calendario & Riesgo</h2>
      <p class="muted">Operabilidad NYSE Â· eventos de impacto</p>

      <div style="display:flex; flex-direction:column; gap:0.6rem;">
        <div class="pill" id="market-pill">
          <span class="icon">ğŸ¦</span><span id="market-status">Cargandoâ€¦</span>
        </div>

        <div class="pill risk-pill" id="risk-pill">
          <span class="icon">ğŸš¦</span><span id="risk-status">Cargandoâ€¦</span>
          <span class="tooltip" id="risk-tooltip">Razones riesgo</span>
        </div>

        <div id="event-filters" style="display:flex; gap:0.5rem; flex-wrap:wrap; font-size:0.65rem;">
          <label class="pill" style="cursor:pointer;">
            <input type="checkbox" value="high" checked style="accent-color:var(--warn);"/> High
          </label>
          <label class="pill" style="cursor:pointer;">
            <input type="checkbox" value="medium" checked style="accent-color:var(--accent);"/> Medium
          </label>
          <label class="pill" style="cursor:pointer;">
            <input type="checkbox" value="earnings" checked style="accent-color:var(--ok);"/> Earnings
          </label>
        </div>
      </div>

      <div style="margin-top:0.8rem; flex:1; overflow:auto;">
        <h3 style="margin:0 0 0.4rem; font-size:0.85rem; color:#e5f0ff;">Hoy</h3>
        <ul id="today-events" style="margin:0 0 0.8rem; padding-left:1rem; font-size:0.75rem;"></ul>

        <h3 style="margin:0 0 0.4rem; font-size:0.85rem; color:#e5f0ff;">PrÃ³ximos dÃ­as</h3>
        <div class="table-container" style="max-height:420px;">
          <table id="upcoming-days">
            <thead>
              <tr>
                <th>Fecha</th>
                <th>Operable</th>
                <th>Riesgo</th>
                <th>Eventos clave</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </aside>

  <main>
    <!-- Alert banner para buffers stale (ocultado, ahora solo icono en header) -->
    <div id="staleBufferAlert" style="display:none;" class="alert-banner">
      <span class="icon" style="font-size:1.2rem;">âš ï¸</span>
      <span><strong>Buffers desactualizados:</strong> <span id="staleBufferMsg"></span> Ejecuta <code>python scripts/download_intraday_for_plan.py</code> para refrescar precios.</span>
    </div>

    <!-- Control Panel (Fase 1) -->
    <section class="grid" style="margin-bottom: 1.5rem;">
      <div class="card" id="control-panel" data-card-id="control-panel" style="grid-column: span 12;">
        <h2>Control del sistema</h2>

        <div class="control-section" style="margin-top:0.5rem; margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem;">Monitor intradÃ­a</h3>
          <label for="monitor-interval">Intervalo (segundos):</label>
          <input id="monitor-interval" type="number" value="300" min="60" step="60"
                 style="margin:0 0.5rem; background:rgba(15,23,42,0.9); color:var(--text); border:1px solid var(--border); border-radius:0.25rem; padding:0.25rem 0.5rem;"/>
          <button id="btn-monitor-start" class="btn"><span class="icon">â–¶</span>Iniciar monitor</button>
          <button id="btn-monitor-stop" class="btn"><span class="icon">â– </span>Detener monitor</button>
          <p id="monitor-status" style="margin-top:0.5rem; color:var(--muted);">Estado monitor: desconocido</p>
        </div>

        <div class="control-section">
          <h3 style="margin:0 0 0.5rem;">Limpieza de workspace (Soft)</h3>
          <button id="btn-clean-soft-dryrun" class="btn"><span class="icon">ğŸ§ª</span>Soft Clean (DryRun)</button>
          <button id="btn-clean-soft" class="btn" style="background:#1f2937; border:1px solid #334155; color:#e5e7eb; margin-left:0.5rem;">ğŸ§¹ Soft Clean (Real)</button>
          <pre id="clean-output" style="max-height: 200px; overflow:auto; background:#0b1120; color:#e5e7eb; padding:0.5rem; border-radius:0.5rem; margin-top:0.75rem;"></pre>
        </div>
      </div>
    </section>

    <!-- KPIs principales -->
    <section class="grid" style="margin-bottom: 1rem;">
  <div class="card kpi-card" data-card-id="positions" style="grid-column: span 3;">
        <h2><span class="icon">ğŸ“Š</span> Posiciones</h2>
        <p>Resumen de estados: Activas vs Cerradas (TP/SL).</p>
        <div class="kpi-value" id="positionsActive">â€“</div>
        <div class="kpi-label">
          Activas: <span id="countActive">0</span> Â·
          TP: <span class="badge-ok" id="countTP">0</span> Â·
          SL: <span class="badge-fail" id="countSL">0</span>
        </div>
      </div>

  <div class="card kpi-card" data-card-id="pnl" style="grid-column: span 3;">
        <h2><span class="icon">ğŸ’°</span> PnL Agregado</h2>
        <p>Suma USD y media % de posiciones cerradas.</p>
        <div class="kpi-value" id="pnlUSD">â€“</div>
        <div class="kpi-label">
          PnL Medio: <span id="pnlPct">â€“</span> %
        </div>
      </div>

  <div class="card kpi-card" data-card-id="buffers" style="grid-column: span 3;">
        <h2><span class="icon">ğŸ“¡</span> Buffers</h2>
        <p>Estado de frescura de precios intradÃ­a.</p>
        <div class="kpi-value" id="bufferFreshness">â€“</div>
        <div class="kpi-label" id="bufferDetails">Esperando datosâ€¦</div>
      </div>

  <div class="card kpi-card" data-card-id="progress-kpi" style="grid-column: span 3;">
        <h2><span class="icon">ğŸ¯</span> Progreso TP</h2>
        <p>Avance promedio y rango minâ€“max de progreso a TP (posiciones activas).</p>
        <div class="kpi-value" id="avgProgressTP">â€“</div>
        <div class="kpi-label">Rango: <span id="progressRange">â€“</span></div>
      </div>
    </section>

    <!-- GrÃ¡ficas -->
    <section class="grid">
      <div class="card" data-card-id="chart-progress" style="grid-column: span 4;">
        <h2><span class="icon">ğŸ“ˆ</span> Progreso a TP por ticker (activos)</h2>
        <p>Serie temporal de progreso hacia take profit para posiciones activas.</p>
        <canvas id="progressChart"></canvas>
      </div>

      <div class="card" data-card-id="chart-equity" style="grid-column: span 4;">
        <h2><span class="icon">ğŸ’¹</span> Equity Curve</h2>
        <p>PnL acumulado USD de trades cerrados en el tiempo.</p>
        <canvas id="equityChart"></canvas>
      </div>

      <div class="card" data-card-id="chart-exit" style="grid-column: span 4;">
        <h2><span class="icon">ğŸ</span> Exit reasons</h2>
        <p>DistribuciÃ³n de motivos de cierre segÃºn la bitÃ¡cora.</p>
        <canvas id="exitReasonChart"></canvas>
      </div>
    </section>

    <!-- Tablas -->
    <section>
      <h3 class="section-title">
        <span class="icon">ğŸ§¾</span> BitÃ¡cora multiday (<code>outputs/bitacora_intraday.csv</code>)
      </h3>
      <div class="table-container" id="bitacoraTableContainer"></div>
    </section>

    <section>
      <h3 class="section-title">
        <span class="icon">ğŸ©º</span> Health monitor (<code>outputs/monitor_health.json</code>)
      </h3>
      <div class="card" style="margin-top:0.5rem;">
        <pre id="healthRaw" style="font-size:0.75rem; white-space:pre-wrap; word-wrap:break-word; margin:0;"></pre>
      </div>
    </section>
  </main>
  <footer class="site-footer">
    <div>Dashboard Multiday Â· VersiÃ³n UI 1.1 Â· <span id="apiStatus">API: comprobandoâ€¦</span> Â· <a href="#" id="quickForwardLink">Ver resumen forward</a></div>
  </footer>
</div>

<!-- Ayuda si API no responde -->
<div id="apiHelpOverlay" class="api-help-overlay">
  <div class="api-help-box">
    <h2>API no disponible</h2>
    <p>No se pudo contactar el servidor Flask en ninguno de los puertos candidatos (5001â€“5005). Sigue estos pasos rÃ¡pidos:</p>
    <ol>
      <li>AsegÃºrate de abrir una ventana <strong>PowerShell separada</strong> y ejecutar:<br/><code>$env:API_PORT=5001; python -u dashboard_api.py</code></li>
      <li>Deja esa ventana abierta; no cierres el proceso. Debes ver <code>Running on http://127.0.0.1:5001</code> (o puerto alterno).</li>
      <li>Si el puerto 5001 estÃ¡ ocupado, prueba: <code>$env:API_PORT=5002; python -u dashboard_api.py</code></li>
      <li>Verifica que existe <code>outputs/api_port.json</code> despuÃ©s de iniciar.</li>
      <li>Recarga este dashboard (Ctrl+R / F5) tras iniciar el servidor.</li>
      <li>Para logs persistentes, usa el script: <code>./run_dashboard_api.ps1</code></li>
    </ol>
    <p>Si persiste el problema, revisa firewall/antivirus y confirma que Flask estÃ© instalado (<code>pip install -r requirements.txt</code>).</p>
    <button id="apiHelpDismiss" class="api-help-dismiss">Cerrar y reintentar</button>
  </div>
</div>

<script>
  // API base dinÃ¡mico: intenta leer outputs/api_port.json o escanear puertos candidatos.
  let API_BASE = null;
  async function detectApiBase() {
    // Intento 1: leer archivo local api_port.json (solo funcionarÃ¡ si servido via HTTP y CORS lo permite)
    try {
      const rLocal = await fetch('outputs/api_port.json');
      if (rLocal.ok) {
        const portInfo = await rLocal.json();
        if (portInfo.port) {
          API_BASE = `http://127.0.0.1:${portInfo.port}/api`;
          return API_BASE;
        }
      }
    } catch (e) { /* continuar */ }
    // Intento 2: escanear puertos usando /api/meta/port (mÃ¡s rÃ¡pido que /api/status si disponible)
    const candidates = [5001,5002,5003,5004,5005];
    for (const p of candidates) {
      try {
        const ctrl = new AbortController();
        const t = setTimeout(()=>ctrl.abort(), 900);
        const rMeta = await fetch(`http://127.0.0.1:${p}/api/meta/port`, { signal: ctrl.signal });
        clearTimeout(t);
        if (rMeta.ok) {
          const metaPort = await rMeta.json();
          if (metaPort.ok && metaPort.port) {
            API_BASE = `http://127.0.0.1:${p}/api`;
            return API_BASE;
          }
        }
      } catch (e) { /* puerto no responde meta */ }
    }
    // Intento 3: escanear puertos con /api/status
    for (const p of candidates) {
      try {
        const ctrl = new AbortController();
        const t = setTimeout(()=>ctrl.abort(), 900);
        const rStatus = await fetch(`http://127.0.0.1:${p}/api/status`, { signal: ctrl.signal });
        clearTimeout(t);
        if (rStatus.ok) { API_BASE = `http://127.0.0.1:${p}/api`; return API_BASE; }
      } catch (e) { /* puerto no responde status */ }
    }
    // Fallback final
    API_BASE = 'http://127.0.0.1:5001/api';
    return API_BASE;
  }

  // Loader global helpers
  function showGlobalLoader(msg="Procesandoâ€¦") {
    const ov = document.getElementById('loaderOverlay');
    const m = document.getElementById('loaderMsg');
    if (m) m.textContent = msg;
    if (ov) ov.style.display = 'flex';
  }
  function hideGlobalLoader() {
    const ov = document.getElementById('loaderOverlay');
    if (ov) ov.style.display = 'none';
  }

  async function callApi(path, options = {}) {
    let response;
    try {
      response = await fetch(`${API_BASE}${path}`, {
        headers: { "Content-Type": "application/json" },
        ...options,
      });
    } catch (netErr) {
      // Error de red. Intentar redetecciÃ³n del puerto (por si el servidor se iniciÃ³ en otro puerto tras cargar el dashboard)
      const previousBase = API_BASE;
      try {
        await detectApiBase();
        if (API_BASE !== previousBase) {
          // Reintentar una vez automÃ¡ticamente con el nuevo API_BASE
          try {
            response = await fetch(`${API_BASE}${path}`, {
              headers: { "Content-Type": "application/json" },
              ...options,
            });
          } catch (retryErr) {
            throw new Error(`Fallo de red tras reintentar (${path}). API_BASE=${API_BASE}. Detalle: ${retryErr.message}`);
          }
        } else {
          throw new Error(`Fallo de red al contactar API (${path}). API_BASE=${API_BASE}. Detalle: ${netErr.message}`);
        }
      } catch (redetectErr) {
        // RedetecciÃ³n tambiÃ©n fallÃ³
        throw new Error(`Fallo de red y redetecciÃ³n (${path}). API_BASE=${API_BASE}. Detalle: ${netErr.message}`);
      }
    }
    let data = {};
    try { data = await response.json(); } catch (parseErr) {
      // Si no se pudo parsear JSON, proveer contenido bruto para diagnÃ³stico.
      const rawText = await response.text().catch(() => "<sin cuerpo>");
      throw new Error(`Respuesta no JSON (${response.status}) en ${path}: ${rawText.substring(0,180)}...`);
    }
    if (!response.ok || data.ok === false) {
      const msg = data.error || data.stderr || response.statusText || "Error en API";
      throw new Error(msg);
    }
    return data;
  }

  // Calendario & Riesgo
  async function loadCalendar() {
    try {
      const todayRes = await callApi("/calendar/today", { method: "GET" });
      const upcomingRes = await callApi("/calendar/upcoming", { method: "GET" });

      const mStatus = document.getElementById("market-status");
      const rStatus = document.getElementById("risk-status");
      const todayEventsEl = document.getElementById("today-events");
      const upcomingBody = document.querySelector("#upcoming-days tbody");
      const riskTooltipEl = document.getElementById("risk-tooltip");
      const filterContainer = document.getElementById("event-filters");
      const activeFilters = filterContainer ? Array.from(filterContainer.querySelectorAll('input:checked')).map(cb => cb.value) : [];

      function filterEvents(events) {
        if (!activeFilters.length) return [];
        return (events || []).filter(ev => {
          if (ev.importance === 'high' && activeFilters.includes('high')) return true;
          if (ev.importance === 'medium' && activeFilters.includes('medium')) return true;
          if (ev.type === 'earnings' && activeFilters.includes('earnings')) return true;
          return false;
        });
      }

      // Mercado hoy
      const market = todayRes.market || {};
      if (market.is_trading_day) mStatus.textContent = "Mercado: ABIERTO";
      else mStatus.textContent = `Mercado: CERRADO (${market.reason || "no operable"})`;

      // Riesgo hoy
      const risk = todayRes.risk || { level: "low", reasons: [] };
      let emoji = "ğŸŸ¢";
      if (risk.level === "medium") emoji = "ğŸŸ¡";
      if (risk.level === "high") emoji = "ğŸ”´";
      rStatus.textContent = `Riesgo: ${emoji} ${String(risk.level || "low").toUpperCase()}`;

      const riskPill = document.getElementById('risk-pill');
      if (riskPill) {
        riskPill.classList.remove('risk-low','risk-medium','risk-high');
        riskPill.classList.add(`risk-${risk.level}`);
      }

      if (riskTooltipEl) {
        if (risk.reasons && risk.reasons.length) {
          riskTooltipEl.innerHTML = risk.reasons.map(r => `<div>${r}</div>`).join("") || "Sin razones elevadas";
        } else riskTooltipEl.textContent = "Sin razones elevadas";
      }

      // Eventos de hoy
      todayEventsEl.innerHTML = "";
      const events = filterEvents(todayRes.events || []);
      if (!events.length) {
        const li = document.createElement("li");
        li.textContent = "Sin eventos relevantes";
        todayEventsEl.appendChild(li);
      } else {
        events.forEach(ev => {
          const li = document.createElement("li");
          const time = ev.time_et ? `${ev.time_et} ET - ` : "";
          const tickerPart = ev.ticker ? `[${ev.ticker}] ` : "";
          const imp = ev.importance ? ` (${ev.importance})` : "";
          li.textContent = `${time}${tickerPart}${ev.description || "Evento"}${imp}`;
          todayEventsEl.appendChild(li);
        });
      }

      // PrÃ³ximos dÃ­as
      upcomingBody.innerHTML = "";
      (upcomingRes.days || []).forEach(day => {
        const tr = document.createElement("tr");

        const tdDate = document.createElement("td");
        tdDate.textContent = day.date;

        const tdOpen = document.createElement("td");
        if (day.is_trading_day) tdOpen.textContent = "SÃ­";
        else {
          if (day.reason && String(day.reason).startsWith("Holiday")) tdOpen.innerHTML = `No <span class="badge-holiday">Holiday</span>`;
          else tdOpen.textContent = "No";
        }

        const tdRisk = document.createElement("td");
        let e = "ğŸŸ¢";
        if (day.risk_level === "medium") e = "ğŸŸ¡";
        if (day.risk_level === "high") e = "ğŸ”´";
        tdRisk.textContent = `${e} ${day.risk_level}`;
        tdRisk.classList.add('risk-cell', `risk-${day.risk_level}`);

        const tdEvents = document.createElement("td");
        const evs = filterEvents(day.events || []);
        tdEvents.textContent = evs.length
          ? evs.map(ev => (ev.ticker ? `[${ev.ticker}] ${ev.description}` : ev.description)).join("; ")
          : "â€”";

        tr.appendChild(tdDate);
        tr.appendChild(tdOpen);
        tr.appendChild(tdRisk);
        tr.appendChild(tdEvents);
        upcomingBody.appendChild(tr);
      });
    } catch (err) {
      console.error("Error loading calendar", err);
      const mStatus = document.getElementById("market-status");
      const rStatus = document.getElementById("risk-status");
      if (mStatus) mStatus.textContent = "Mercado: N/D";
      if (rStatus) rStatus.textContent = "Riesgo: N/D";
    }
  }

  async function updateMonitorStatus() {
    const statusEl = document.getElementById("monitor-status");
    if (!statusEl) return;
    try {
      const data = await callApi("/status", { method: "GET" });
      const running = data.monitor?.running;
      const interval = data.monitor?.interval_seconds;
      const pid = data.monitor?.pid;
      const startedAt = data.monitor?.started_at;

      let estado = "desconocido";
      if (running === true) {
        estado = `RUNNING (cada ${interval || "?"}s)`;
        if (pid) estado += ` Â· PID ${pid}`;
        if (startedAt) {
          const dt = new Date(startedAt);
          estado += ` Â· desde ${dt.toLocaleTimeString()}`;
        }
      } else if (running === false) estado = "STOPPED";

      statusEl.textContent = `Estado monitor: ${estado}`;
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Estado monitor: error al consultar";
    }
  }

  function setupControlPanel() {
    const btnStart = document.getElementById("btn-monitor-start");
    const btnStop = document.getElementById("btn-monitor-stop");
    const intervalInput = document.getElementById("monitor-interval");
    const btnSoftDryRun = document.getElementById("btn-clean-soft-dryrun");
    const btnSoftReal = document.getElementById("btn-clean-soft");
    const cleanOutput = document.getElementById("clean-output");

    if (!btnStart || !btnStop || !btnSoftDryRun || !btnSoftReal) {
      console.warn("Control panel elements not found; skipping setupControlPanel.");
      return;
    }

    btnStart.addEventListener("click", async () => {
      try {
        const interval = parseInt((intervalInput?.value || "300"), 10);
        const data = await callApi("/monitor/start", {
          method: "POST",
          body: JSON.stringify({ interval_seconds: interval }),
        });
        alert(data.message || "Monitor iniciado");
        updateMonitorStatus();
      } catch (err) {
        console.error(err);
        alert("Error al iniciar monitor: " + err.message);
      }
    });

    btnStop.addEventListener("click", async () => {
      try {
        const data = await callApi("/monitor/stop", { method: "POST" });
        alert(data.message || "Se intentÃ³ detener el monitor");
        updateMonitorStatus();
      } catch (err) {
        console.error(err);
        alert("Error al detener monitor: " + err.message);
      }
    });

    btnSoftDryRun.addEventListener("click", async () => {
      if (cleanOutput) cleanOutput.textContent = "Ejecutando Soft Clean (DryRun)...\n";
      try {
        const data = await callApi("/clean/soft", {
          method: "POST",
          body: JSON.stringify({ dry_run: true }),
        });
        if (cleanOutput) cleanOutput.textContent = (data.stdout || "").trim() || "(sin salida de consola)";
      } catch (err) {
        console.error(err);
        if (cleanOutput) cleanOutput.textContent = "Error: " + err.message;
      }
    });

    btnSoftReal.addEventListener("click", async () => {
      if (!confirm("Â¿Seguro que quieres ejecutar Soft Clean (REAL)?")) return;
      if (cleanOutput) cleanOutput.textContent = "Ejecutando Soft Clean (Real)...\n";
      try {
        const data = await callApi("/clean/soft", {
          method: "POST",
          body: JSON.stringify({ dry_run: false }),
        });
        if (cleanOutput) cleanOutput.textContent = (data.stdout || "").trim() || "(sin salida de consola)";
      } catch (err) {
        console.error(err);
        if (cleanOutput) cleanOutput.textContent = "Error: " + err.message;
      }
    });

    updateMonitorStatus();
    setInterval(updateMonitorStatus, 15000);
  }

  function setLastUpdated() {
    const now = new Date();
    const label = document.getElementById("lastUpdatedLabel");
    if (label) label.textContent = `Actualizado: ${now.toLocaleTimeString()}`;
  }

  async function fetchText(path) {
    const res = await fetch(path);
    if (!res.ok) throw new Error("No se pudo cargar " + path + " (" + res.status + ")");
    return res.text();
  }

  async function fetchJSON(path) {
    const res = await fetch(path);
    if (!res.ok) throw new Error("No se pudo cargar " + path + " (" + res.status + ")");
    return res.json();
  }

  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (lines.length === 0) return { headers: [], rows: [] };
    const headers = lines[0].split(",").map(h => h.trim());
    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      if (!lines[i].trim()) continue;
      const parts = lines[i].split(",");
      const row = {};
      headers.forEach((h, idx) => row[h] = (parts[idx] !== undefined ? parts[idx].trim() : ""));
      rows.push(row);
    }
    return { headers, rows };
  }

  function renderTable(containerId, headers, rows) {
    const container = document.getElementById(containerId);
    if (!headers.length || !rows.length) {
      container.innerHTML = "<div class='muted' style='padding:0.75rem;'>Sin datos para mostrar.</div>";
      return;
    }
    let html = "<table><thead><tr>";
    headers.forEach(h => html += `<th>${h}</th>`);
    html += "</tr></thead><tbody>";
    rows.forEach(row => {
      html += "<tr>";
      headers.forEach(h => {
        let val = row[h] ?? "";
        let cls = "";
        if (h.toLowerCase() === "status") {
          if (val === "ACTIVO") cls = "status-activo";
          else if (val === "TP_HIT") cls = "status-tp-hit";
          else if (val === "SL_HIT") cls = "status-sl-hit";
        }
        if (h.toLowerCase() === "ok") {
          if (val.toLowerCase() === "true" || val === "1") { cls = "badge-ok"; val = "OK"; }
          else if (val.toLowerCase() === "false" || val === "0") { cls = "badge-fail"; val = "FAIL"; }
        }
        html += `<td class="${cls}">${val}</td>`;
      });
      html += "</tr>";
    });
    html += "</tbody></table>";
    container.innerHTML = html;
  }

  // GrÃ¡ficas
  let progressChart, equityChart, exitChart;

  function renderProgressChart(activeTickersSeries) {
    const ctx = document.getElementById("progressChart").getContext("2d");
    if (progressChart) progressChart.destroy();

    if (!activeTickersSeries || activeTickersSeries.length === 0) {
      progressChart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [] },
        options: {
          plugins: {
            legend: { display: false },
            title: { display: true, text: 'Sin posiciones activas con datos de progreso', color: '#9ca3af', font: { size: 14 } }
          }
        }
      });
      return;
    }

    const colors = [
      { border: '#38bdf8', bg: 'rgba(56, 189, 248, 0.15)' },
      { border: '#4ade80', bg: 'rgba(74, 222, 128, 0.15)' },
      { border: '#facc15', bg: 'rgba(250, 204, 21, 0.15)' },
      { border: '#f97373', bg: 'rgba(249, 115, 115, 0.15)' },
      { border: '#a78bfa', bg: 'rgba(167, 139, 250, 0.15)' }
    ];

    const datasets = activeTickersSeries.map((item, idx) => {
      const colorPair = colors[idx % colors.length];
      return {
        label: item.ticker,
        data: item.data.map(d => ({ x: d.timestamp, y: parseFloat(d.progreso_tp) })),
        borderColor: colorPair.border,
        backgroundColor: colorPair.bg,
        tension: 0.4,
        pointRadius: 4,
        pointHoverRadius: 6,
        pointBackgroundColor: colorPair.border,
        pointBorderColor: '#0f172a',
        pointBorderWidth: 2,
        borderWidth: 3,
        fill: true
      };
    });

    const allLabels = [];
    activeTickersSeries.forEach(item => item.data.forEach(d => { if (!allLabels.includes(d.timestamp)) allLabels.push(d.timestamp); }));
    allLabels.sort();

    progressChart = new Chart(ctx, {
      type: "line",
      data: { labels: allLabels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: {
            position: "top",
            labels: { color: "#e5e7eb", font: { size: 12, weight: '600' }, padding: 15, usePointStyle: true, pointStyle: 'circle' }
          },
          tooltip: {
            backgroundColor: 'rgba(15, 23, 42, 0.95)',
            titleColor: '#e5e7eb',
            bodyColor: '#e5e7eb',
            borderColor: '#38bdf8',
            borderWidth: 1,
            padding: 12,
            callbacks: { label: c => `${c.dataset.label}: ${c.parsed.y.toFixed(2)}%` }
          }
        },
        scales: {
          x: {
            type: 'category',
            ticks: { color: "#9ca3af", maxRotation: 45, minRotation: 0, font: { size: 10 } },
            grid: { color: 'rgba(31, 41, 55, 0.5)', drawBorder: false }
          },
          y: {
            ticks: { color: "#9ca3af", font: { size: 11 }, callback: v => v + '%' },
            beginAtZero: true, max: 100,
            grid: { color: 'rgba(31, 41, 55, 0.5)', drawBorder: false },
            title: { display: true, text: 'Progreso a TP (%)', color: '#9ca3af', font: { size: 12, weight: '600' } }
          }
        },
        animation: { duration: 750, easing: 'easeInOutQuart' }
      }
    });
  }

  function renderEquityChart(equityData) {
    const ctx = document.getElementById("equityChart").getContext("2d");
    if (equityChart) equityChart.destroy();

    if (!equityData || equityData.length === 0) {
      equityChart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [] },
        options: { plugins: { legend: { display: false }, title: { display: true, text: 'Sin trades cerrados aÃºn', color: '#9ca3af', font: { size: 14 } } } }
      });
      return;
    }

    const labels = equityData.map(d => d['Fecha Cierre'] || '');
    const pnlAccum = equityData.map(d => parseFloat(d['PnL_Acumulado'] || 0));
    const gradient = ctx.createLinearGradient(0, 0, 0, 280);
    const finalPnL = pnlAccum[pnlAccum.length - 1] || 0;

    if (finalPnL >= 0) {
      gradient.addColorStop(0, 'rgba(74, 222, 128, 0.3)');
      gradient.addColorStop(1, 'rgba(74, 222, 128, 0.05)');
    } else {
      gradient.addColorStop(0, 'rgba(249, 115, 115, 0.3)');
      gradient.addColorStop(1, 'rgba(249, 115, 115, 0.05)');
    }

    equityChart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [{
          label: 'PnL Acumulado USD',
          data: pnlAccum,
          borderColor: finalPnL >= 0 ? '#4ade80' : '#f97373',
          backgroundColor: gradient,
          tension: 0.4,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointBackgroundColor: finalPnL >= 0 ? '#4ade80' : '#f97373',
          pointBorderColor: '#0f172a',
          pointBorderWidth: 2,
          borderWidth: 3,
          fill: true
        }]
      },
      options: {
        responsive: true, maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            backgroundColor: 'rgba(15, 23, 42, 0.95)',
            titleColor: '#e5e7eb',
            bodyColor: '#e5e7eb',
            borderColor: '#38bdf8',
            borderWidth: 1,
            padding: 12,
            callbacks: { label: c => `PnL Acum: $${c.parsed.y.toFixed(2)}` }
          }
        },
        scales: {
          x: { ticks: { color: "#9ca3af", maxRotation: 45, minRotation: 0, font: { size: 10 } }, grid: { color: 'rgba(31, 41, 55, 0.5)', drawBorder: false } },
          y: {
            ticks: { color: "#9ca3af", font: { size: 11 }, callback: v => '$' + v.toFixed(0) },
            grid: { color: 'rgba(31, 41, 55, 0.5)', drawBorder: false },
            title: { display: true, text: 'PnL Acumulado (USD)', color: '#9ca3af', font: { size: 12, weight: '600' } }
          }
        },
        animation: { duration: 750, easing: 'easeInOutQuart' }
      }
    });
  }

  function renderExitChart(exitCounts) {
    const ctx = document.getElementById("exitReasonChart").getContext("2d");
    const labels = Object.keys(exitCounts);
    const data = labels.map(l => exitCounts[l]);

    if (exitChart) exitChart.destroy();

    if (labels.length === 0) {
      exitChart = new Chart(ctx, {
        type: "doughnut",
        data: { labels: [], datasets: [] },
        options: { plugins: { legend: { display: false }, title: { display: true, text: 'Sin datos de salidas', color: '#9ca3af', font: { size: 14 } } } }
      });
      return;
    }

    const colorMap = {
      'TP_natural': '#4ade80',
      'SL_natural': '#f97373',
      'Manual': '#facc15',
      'Open': '#38bdf8',
      'Trailing_TP': '#10b981',
      'Time_Exit': '#a78bfa'
    };

    const backgroundColors = labels.map(l => colorMap[l] || '#64748b');
    const hoverColors = labels.map(l => (colorMap[l] || '#64748b') + 'dd');
    const totalTrades = data.reduce((a, b) => a + b, 0);

    const centerTextPlugin = {
      id: 'centerText',
      beforeDraw: (chart) => {
        const { ctx, chartArea: { width, height } } = chart;
        ctx.save();
        ctx.font = 'bold 32px sans-serif';
        ctx.fillStyle = '#e5e7eb';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(totalTrades, width / 2, height / 2 - 10);
        ctx.font = '12px sans-serif';
        ctx.fillStyle = '#9ca3af';
        ctx.fillText('Trades', width / 2, height / 2 + 20);
        ctx.restore();
      }
    };

    exitChart = new Chart(ctx, {
      type: "doughnut",
      data: {
        labels: labels.map(l => l.replace(/_/g, ' ').replace('natural', '').trim()),
        datasets: [{
          data,
          backgroundColor: backgroundColors,
          hoverBackgroundColor: hoverColors,
          borderColor: '#0f172a',
          borderWidth: 3,
          hoverBorderWidth: 4,
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true, maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "right",
            labels: { color: "#e5e7eb", font: { size: 12, weight: '500' }, padding: 12, boxWidth: 15, boxHeight: 15, usePointStyle: true, pointStyle: 'circle' }
          },
          tooltip: {
            backgroundColor: 'rgba(15, 23, 42, 0.95)',
            titleColor: '#e5e7eb',
            bodyColor: '#e5e7eb',
            borderColor: '#38bdf8',
            borderWidth: 1,
            padding: 12,
            callbacks: {
              label: c => {
                const label = c.label || '';
                const value = c.parsed || 0;
                const total = c.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((value / total) * 100).toFixed(1);
                return `${label}: ${value} (${pct}%)`;
              }
            }
          }
        },
        animation: { animateRotate: true, animateScale: true, duration: 800, easing: 'easeOutQuart' },
        cutout: '65%'
      },
      plugins: [centerTextPlugin]
    });
  }

  async function loadAll() {
    try {
      setLastUpdated();
      loadCalendar();

      // 1) Health
      let health;
      try {
        const statusResp = await callApi("/status", { method: "GET" });
        health = statusResp.health || null;
      } catch (e) {
        try { health = await fetchJSON("outputs/monitor_health.json"); }
        catch (e2) { health = null; console.warn("Health no disponible:", e2); }
      }

      const healthRawEl = document.getElementById("healthRaw");
      if (healthRawEl && health) healthRawEl.textContent = JSON.stringify(health, null, 2);

      const freshBuffers = health?.fresh_buffers || 0;
      const totalBuffers = health?.total_buffers || 0;

      const bufferFreshnessEl = document.getElementById("bufferFreshness");
      const bufferDetailsEl = document.getElementById("bufferDetails");

      if (bufferFreshnessEl && bufferDetailsEl) {
        if (totalBuffers === 0) {
          bufferFreshnessEl.innerHTML = "<span class='status-dot status-warn'></span>Sin buffers";
          bufferDetailsEl.textContent = "No hay posiciones activas o buffers no generados.";
        } else {
          const pctFresh = ((freshBuffers / totalBuffers) * 100).toFixed(0);
          let dotClass = "status-ok";
          if (freshBuffers === 0) dotClass = "status-bad";
          else if (freshBuffers < totalBuffers) dotClass = "status-warn";
          bufferFreshnessEl.innerHTML = `<span class='status-dot ${dotClass}'></span>${freshBuffers}/${totalBuffers}`;
          bufferDetailsEl.textContent = `${pctFresh}% frescos (< 10 min)`;
        }
      }

      const alertIconEl = document.getElementById("staleBufferIcon");
      const alertTooltipEl = document.getElementById("staleBufferTooltip");
      if (alertIconEl && alertTooltipEl) {
        if (freshBuffers === 0 && totalBuffers > 0) {
          alertTooltipEl.textContent = `âš ï¸ ${totalBuffers} buffer(s) desactualizados (>10 min). Ejecuta download_intraday_for_plan.py`;
          alertIconEl.style.display = "inline-flex";
        } else if (freshBuffers < totalBuffers) {
          const staleCount = totalBuffers - freshBuffers;
          alertTooltipEl.textContent = `âš ï¸ ${staleCount} de ${totalBuffers} buffer(s) desactualizados`;
          alertIconEl.style.display = "inline-flex";
        } else {
          alertIconEl.style.display = "none";
        }
      }

      if (!health && healthRawEl) healthRawEl.textContent = "monitor_health.json no disponible.";
      if (!health && bufferFreshnessEl) bufferFreshnessEl.innerHTML = "<span class='status-dot status-warn'></span>N/D";
      if (!health && bufferDetailsEl) bufferDetailsEl.textContent = "Health no disponible";

      // 2) BitÃ¡cora intradÃ­a
      let rowsB = null, headersB = null;
      try {
        const apiB = await callApi("/bitacora", { method: "GET" });
        rowsB = apiB.data || [];
        headersB = rowsB.length ? Object.keys(rowsB[0]) : [];
      } catch (e) {
        try {
          const bitacoraCSV = await fetchText("outputs/bitacora_intraday.csv");
          const parsedB = parseCSV(bitacoraCSV);
          rowsB = parsedB.rows;
          headersB = parsedB.headers;
        } catch (e2) {
          console.warn("bitacora no disponible vÃ­a API ni archivo:", e2);
          rowsB = null; headersB = null;
        }
      }

      if (rowsB) {
        renderTable("bitacoraTableContainer", headersB || [], rowsB);

        let countActive = 0, countTP = 0, countSL = 0;
        const exitCounts = {};
        let progressSum = 0, progressCount = 0, progressMin = 100, progressMax = 0;
        let pnlUSDSum = 0, pnlPctSum = 0, pnlCount = 0;

        const activeTickers = [];

        rowsB.forEach(r => {
          const status = (r["Status"] || "").trim();
          if (status === "ACTIVO") {
            countActive++;
            activeTickers.push(r["Ticker"] || r["ticker"] || "N/A");
          } else if (status === "TP_HIT") countTP++;
          else if (status === "SL_HIT") countSL++;

          const reason = (r["Exit Reason"] || r["Exit_Reason"] || r["exit_reason"] || "Open").trim() || "Open";
          exitCounts[reason] = (exitCounts[reason] || 0) + 1;

          const prog = parseFloat(r["Progreso a TP %"] || r["progreso_tp"] || "");
          if (!isNaN(prog) && status === "ACTIVO") {
            progressSum += prog; progressCount++;
            if (prog < progressMin) progressMin = prog;
            if (prog > progressMax) progressMax = prog;
          }

          if (status === "TP_HIT" || status === "SL_HIT") {
            const pnlUSD = parseFloat(r["PnL USD"] || r["pnl_usd"] || "0");
            const pnlPct = parseFloat(r["PnL %"] || r["pnl_pct"] || "0");
            if (!isNaN(pnlUSD)) { pnlUSDSum += pnlUSD; pnlCount++; }
            if (!isNaN(pnlPct)) pnlPctSum += pnlPct;
          }
        });

        document.getElementById("positionsActive").textContent = rowsB.length.toString();
        document.getElementById("countActive").textContent = countActive;
        document.getElementById("countTP").textContent = countTP;
        document.getElementById("countSL").textContent = countSL;

        const elPnlUSD = document.getElementById("pnlUSD");
        const elPnlPct = document.getElementById("pnlPct");
        if (pnlCount > 0) {
          elPnlUSD.textContent = `$${pnlUSDSum.toFixed(2)}`;
          elPnlPct.textContent = (pnlPctSum / pnlCount).toFixed(2);
        } else { elPnlUSD.textContent = "â€“"; elPnlPct.textContent = "â€“"; }

        const elAvgProgressTP = document.getElementById("avgProgressTP");
        const elProgressRange = document.getElementById("progressRange");
        const avgProg = progressCount ? (progressSum / progressCount) : null;
        elAvgProgressTP.textContent = avgProg != null ? avgProg.toFixed(1) + " %" : "â€“";
        elProgressRange.textContent = progressCount > 0 ? `${progressMin.toFixed(1)}% - ${progressMax.toFixed(1)}%` : "â€“";

        renderExitChart(exitCounts);

        const progressSeriesPromises = activeTickers.map(async (ticker) => {
          try {
            const apiP = await callApi(`/progress/${ticker}`, { method: "GET" });
            return { ticker, data: apiP.data || [] };
          } catch (e) {
            try {
              const csv = await fetchText(`outputs/progress_series_${ticker}.csv`);
              const parsed = parseCSV(csv);
              return { ticker, data: parsed.rows };
            } catch (e2) {
              console.warn(`Progress series for ${ticker} not available`);
              return null;
            }
          }
        });

        const progressSeries = (await Promise.all(progressSeriesPromises)).filter(x => x !== null);
        renderProgressChart(progressSeries);

        try {
          const apiEq = await callApi("/equity", { method: "GET" });
          renderEquityChart(apiEq.data || []);
        } catch (e) {
          try {
            const equityCSV = await fetchText("outputs/equity_curve.csv");
            renderEquityChart(parseCSV(equityCSV).rows);
          } catch (e2) {
            console.warn("equity_curve.csv no disponible:", e2);
            renderEquityChart([]);
          }
        }
      } else {
        renderTable("bitacoraTableContainer", [], []);
        document.getElementById("positionsActive").textContent = "â€“";
        document.getElementById("countActive").textContent = "0";
        document.getElementById("countTP").textContent = "0";
        document.getElementById("countSL").textContent = "0";
        document.getElementById("pnlUSD").textContent = "â€“";
        document.getElementById("pnlPct").textContent = "â€“";
        document.getElementById("avgProgressTP").textContent = "â€“";
        document.getElementById("progressRange").textContent = "â€“";
        renderExitChart({});
        renderProgressChart([]);
        renderEquityChart([]);
      }

    } catch (err) {
      console.error("Error cargando el panel:", err);
      alert("Error cargando el panel multiday. Revisa la consola (F12) para mÃ¡s detalles.");
    }
  }

  // ===== Layout editable: persistencia simple en localStorage =====
  const LAYOUT_KEY = 'dashboardLayoutV1';

  function loadLayoutPrefs() {
    try { return JSON.parse(localStorage.getItem(LAYOUT_KEY) || '{}'); }
    catch (e) { return {}; }
  }

  function saveLayoutPrefs(prefs) {
    try { localStorage.setItem(LAYOUT_KEY, JSON.stringify(prefs)); }
    catch (e) {}
  }

  function applyLayoutPrefs() {
    const prefs = loadLayoutPrefs();
    Object.entries(prefs).forEach(([cardId, cfg]) => {
      if (cardId === 'sidebar' && cfg.width) {
        document.documentElement.style.setProperty('--sidebar-w', `${parseInt(cfg.width, 10)}px`);
        return;
      }
      const el = document.querySelector(`.card[data-card-id="${cardId}"]`);
      if (!el) return;
      if (cfg.span) el.style.gridColumn = `span ${cfg.span}`;
      if (cfg.height) {
        if (el.querySelector('canvas')) el.style.setProperty('--chart-h', `${parseInt(cfg.height, 10)}px`);
        else el.style.height = `${parseInt(cfg.height, 10)}px`;
      }
    });
  }

  function setupLayoutEditor() {
    const toggleBtn = document.getElementById('toggleLayoutEdit');
    const resetBtn = document.getElementById('resetLayout');
    if (!toggleBtn || !resetBtn) return;

    function ensureControls(card) {
      if (card.querySelector('.card-controls')) return;
      const controls = document.createElement('div');
      controls.className = 'card-controls';

      const spanLabel = document.createElement('label');
      spanLabel.textContent = 'Cols:';
      spanLabel.style.fontSize = '0.7rem';
      spanLabel.style.color = 'var(--muted)';
      spanLabel.style.marginRight = '0.2rem';

      const spanSel = document.createElement('select');
      [2,3,4,6,8,12].forEach(n => {
        const opt = document.createElement('option');
        opt.value = String(n);
        opt.textContent = String(n);
        spanSel.appendChild(opt);
      });

      const currentSpanMatch = (card.style.gridColumn || '').match(/span\s+(\d+)/);
      if (currentSpanMatch) spanSel.value = currentSpanMatch[1];

      controls.appendChild(spanLabel);
      controls.appendChild(spanSel);

      const hasCanvas = !!card.querySelector('canvas');
      const hLabel = document.createElement('label');
      hLabel.textContent = 'Alto:';
      hLabel.style.fontSize = '0.7rem';
      hLabel.style.color = 'var(--muted)';
      hLabel.style.marginLeft = '0.4rem';
      hLabel.style.marginRight = '0.2rem';

      const heightInput = document.createElement('input');
      heightInput.type = 'number';
      heightInput.min = '180';
      heightInput.max = '800';
      heightInput.step = '10';

      if (hasCanvas) {
        const currentH = getComputedStyle(card).getPropertyValue('--chart-h').trim();
        const m = currentH.match(/(\d+)px/);
        heightInput.value = m ? m[1] : '280';
      } else {
        const h = parseInt(card.style.height || '0', 10);
        heightInput.value = String(h > 0 ? h : 220);
      }

      controls.appendChild(hLabel);
      controls.appendChild(heightInput);

      spanSel.addEventListener('change', () => {
        const n = parseInt(spanSel.value, 10) || 4;
        card.style.gridColumn = `span ${n}`;
        const id = card.getAttribute('data-card-id');
        const prefs = loadLayoutPrefs();
        prefs[id] = Object.assign({}, prefs[id] || {}, { span: n });
        saveLayoutPrefs(prefs);
      });

      heightInput.addEventListener('change', () => {
        const h = Math.max(120, Math.min(1200, parseInt(heightInput.value, 10) || 280));
        const id = card.getAttribute('data-card-id');
        const prefs = loadLayoutPrefs();
        if (hasCanvas) {
          card.style.setProperty('--chart-h', `${h}px`);
          prefs[id] = Object.assign({}, prefs[id] || {}, { height: h });
        } else {
          card.style.height = `${h}px`;
          prefs[id] = Object.assign({}, prefs[id] || {}, { height: h });
        }
        saveLayoutPrefs(prefs);
      });

      if (card.closest('#sidebar')) {
        const wLabel = document.createElement('label');
        wLabel.textContent = 'Ancho:';
        wLabel.style.fontSize = '0.7rem';
        wLabel.style.color = 'var(--muted)';
        wLabel.style.marginLeft = '0.4rem';
        wLabel.style.marginRight = '0.2rem';

        const wInput = document.createElement('input');
        wInput.type = 'number';
        wInput.min = '220';
        wInput.max = '600';
        wInput.step = '10';

        const currentSidebarW = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-w').trim();
        const m = currentSidebarW.match(/(\d+)px/);
        wInput.value = m ? m[1] : '320';

        wInput.addEventListener('change', () => {
          const w = Math.max(220, Math.min(700, parseInt(wInput.value, 10) || 320));
          document.documentElement.style.setProperty('--sidebar-w', `${w}px`);
          const prefs = loadLayoutPrefs();
          prefs['sidebar'] = Object.assign({}, prefs['sidebar'] || {}, { width: w });
          saveLayoutPrefs(prefs);
        });

        controls.appendChild(wLabel);
        controls.appendChild(wInput);
      }

      card.appendChild(controls);
    }

    function buildControls() {
      document.querySelectorAll('.card[data-card-id]').forEach(ensureControls);
    }

    toggleBtn.addEventListener('click', () => {
      document.body.classList.toggle('edit-layout');
      if (document.body.classList.contains('edit-layout')) buildControls();
    });

    resetBtn.addEventListener('click', () => {
      if (!confirm('Â¿Restablecer tamaÃ±os y columnas guardadas?')) return;
      localStorage.removeItem(LAYOUT_KEY);
      document.querySelectorAll('.card[data-card-id]').forEach(card => {
        card.style.removeProperty('grid-column');
        card.style.removeProperty('--chart-h');
        card.style.removeProperty('height');
      });
      applyLayoutPrefs();
    });
  }

  // DOM Ready
  document.addEventListener("DOMContentLoaded", async function() {
    // Detectar puerto antes de cualquier request
    const base = await detectApiBase();
    // Intentar ping inicial
    let apiReachable = false;
    try {
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), 1500);
      const r = await fetch(`${base}/status`, { signal: ctrl.signal });
      clearTimeout(t);
      apiReachable = r.ok;
    } catch (e) { apiReachable = false; }
    if (!apiReachable) {
      const ov = document.getElementById('apiHelpOverlay');
      if (ov) ov.style.display = 'flex';
    }
    const dismissBtn = document.getElementById('apiHelpDismiss');
    if (dismissBtn) dismissBtn.addEventListener('click', ()=>{
      const ov = document.getElementById('apiHelpOverlay');
      if (ov) ov.style.display = 'none';
      // Reintentar detecciÃ³n bÃ¡sica tras cierre
      detectApiBase();
    });
    const apiStatusSpan = document.getElementById("apiStatus");
    if (apiStatusSpan) apiStatusSpan.textContent = `API Base: ${API_BASE}`;
  const reloadBtn = document.getElementById("reloadButton");
  const btnPredicciones = document.getElementById("btnPredicciones");
  const btnRefreshBuffers = document.getElementById("btnRefreshBuffers");
  const btnShowForward = document.getElementById("btnShowForward");
  const quickForwardLink = document.getElementById("quickForwardLink");
    if (reloadBtn) reloadBtn.addEventListener("click", loadAll);

    // BotÃ³n Ãºnico de predicciones (daily + forward)
    if (btnPredicciones) {
      btnPredicciones.addEventListener("click", async () => {
        if (!confirm("Â¿Generar predicciones y plan para maÃ±ana? (Ejecuta daily + forward)")) return;
        btnPredicciones.disabled = true;
        btnPredicciones.classList.add('btn-loading');
        showGlobalLoader('Generando prediccionesâ€¦');
        try {
          const body = { send_telegram: false, recent_days: 3, max_open: 3, capital: 1000, run_daily_first: true };
          const data = await callApi("/pipeline/run_forward", { method: "POST", body: JSON.stringify(body) });
          if (data.forward_skipped) {
            alert("FallÃ³ la etapa diaria, se abortÃ³ la generaciÃ³n forward.");
          } else if (data.ok) {
            const dailyOk = data.history_entry?.daily_step?.ok;
            const planMsg = data.plan_path ? `Plan generado: ${data.plan_path}` : (data.reason_empty_plan || 'Sin plan (filtros).');
            alert(`Predicciones completadas. Daily=${dailyOk ? 'OK' : 'ERROR'}. ${planMsg}`);
          } else {
            alert("Error ejecutando predicciones: " + (data.error || data.stderr || ""));
          }
        } catch (err) {
          console.error(err);
          alert("Fallo ejecutando predicciones: " + err.message);
        } finally {
          hideGlobalLoader();
          btnPredicciones.disabled = false;
          btnPredicciones.classList.remove('btn-loading');
          btnPredicciones.innerHTML = '<span class="icon">ğŸ¤–</span>Predicciones MaÃ±ana';
        }
      });
    }

    // Refrescar buffers intradÃ­a (descarga datos recientes para tickers del plan)
    if (btnRefreshBuffers) {
      btnRefreshBuffers.addEventListener('click', async () => {
        if (!confirm('Â¿Descargar intradÃ­a para tickers del trade plan y refrescar buffers?')) return;
        // Asegurarse de tener la detecciÃ³n mÃ¡s reciente antes de llamar
        await detectApiBase();
        btnRefreshBuffers.disabled = true;
        btnRefreshBuffers.classList.add('btn-loading');
        showGlobalLoader('Descargando intradÃ­aâ€¦');
        try {
          const body = { interval: '5m', days: 1, max_workers: 1, skip_recent: false, save_history: false, dry_run: false };
          const data = await callApi('/plan/download_intraday', { method: 'POST', body: JSON.stringify(body) });
          if (data.ok) {
            alert('Buffers intradÃ­a actualizados. Latencias y mÃ©tricas disponibles en outputs/intraday_metrics.csv');
            // Refrescar KPIs para ver frescura
            await loadAll();
          } else {
            alert('Error refrescando buffers: ' + (data.error || data.stderr_tail || '')); 
          }
        } catch (err) {
          console.error(err);
          alert('Fallo descarga intradÃ­a: ' + err.message);
        } finally {
          hideGlobalLoader();
          btnRefreshBuffers.disabled = false;
          btnRefreshBuffers.classList.remove('btn-loading');
          btnRefreshBuffers.innerHTML = '<span class="icon">ğŸ“¡</span>Refrescar Buffers';
        }
      });
    }
    async function checkApiHealth(){
      try { await callApi("/status", { method:"GET" }); if(apiStatusSpan) apiStatusSpan.textContent = `API OK (${API_BASE})`; }
      catch(e){ if(apiStatusSpan) apiStatusSpan.textContent = `API NO DISPONIBLE (${API_BASE})`; }
    }
    checkApiHealth(); setInterval(checkApiHealth, 30000);
    
    function showForward(summary){
      const s = summary;
      const topLines = (s.top||[]).map((t,i)=>`${i+1}. ${t.ticker} Â· prob=${(t.prob_win||0).toFixed(3)} Â· P(TPâ‰ºSL)=${(t.p_tp_before_sl||0).toFixed(3)} Â· ETTH=${(t.etth||0).toFixed(2)}`).join('\n');
      const msg = `Resumen Forward\nFecha base: ${s.date}\nSeÃ±ales T-1: ${s.n_signals}\nProb(win) media: ${(s.stats?.prob_win_mean||0).toFixed(3)}\nETTH media: ${(s.stats?.etth_mean||0).toFixed(2)}\nP(TPâ‰ºSL) media: ${(s.stats?.p_tp_before_sl_mean||0).toFixed(3)}\n\nTop seÃ±ales:\n${topLines || '(sin seÃ±ales)'}`;
      alert(msg);
    }
    async function fetchForward(){
      const data = await callApi("/pipeline/forward/report", { method: "GET" });
      if(data.ok) showForward(data.summary); else alert("No disponible: "+(data.error||"error"));
    }
    if (btnShowForward) {
      btnShowForward.addEventListener("click", async () => {
        try { await fetchForward(); }
        catch(err){ console.error(err); alert("Error obteniendo resumen forward: "+err.message); }
      });
    }
    if(quickForwardLink){ quickForwardLink.addEventListener("click", async (e)=>{ e.preventDefault(); try{ await fetchForward(); } catch(err){ alert("Error: "+err.message); } }); }

    setupControlPanel();

    const filterContainer = document.getElementById('event-filters');
    if (filterContainer) filterContainer.addEventListener('change', loadCalendar);

    applyLayoutPrefs();
    setupLayoutEditor();

    loadAll();
    loadCalendar();

    // Auto-refresh
    const autoRefreshSelect = document.getElementById("autoRefreshSelect");
    let autoRefreshInterval = null;
    if (autoRefreshSelect) {
      const initialRefresh = parseInt(autoRefreshSelect.value, 10);
      if (initialRefresh > 0) autoRefreshInterval = setInterval(loadAll, initialRefresh * 1000);

      autoRefreshSelect.addEventListener("change", () => {
        const seconds = parseInt(autoRefreshSelect.value, 10);
        if (autoRefreshInterval) clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
        if (seconds > 0) autoRefreshInterval = setInterval(loadAll, seconds * 1000);
      });
    }
  });
</script>
</body>
</html>
